This is a great start to your article! Here's the first part with grammar corrections and code explanations to enhance clarity and professionalism:

## Building a User Authentication System in Node.js, Express, and PostgreSQL from Scratch

This article guides you through the process of building a robust user authentication system using Node.js, the Express.js framework, and a PostgreSQL database. We will start by setting up a new Node.js project and connecting it to our PostgreSQL database.

### Creating a New Node.js Project

First, open your terminal and navigate to your desired project directory. Then, initialize a new Node.js project using the following command:

```bash
npm init
```

This command will guide you through the process of creating a `package.json` file for your project.

### Installing Express and Nodemon

Next, we will install Express, a minimal and flexible Node.js web application framework, and Nodemon, a utility that automatically restarts the server when file changes in the directory are detected during development. Run the following command:

```bash
npm install express nodemon
```

After the installation is complete, open your `package.json` file and add the following scripts:

```json
"scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js"
}
```

**Code explanation:**

* `"start": "node index.js"`: This script defines the command to run your main application file (`index.js`) using Node.js.
* `"dev": "nodemon index.js"`: This script defines the command to run your application using Nodemon. When you make changes to your project files, Nodemon will automatically restart the server, which is very helpful during development.

### Setting Up Environment Variables

Create a `.env` file in the root directory of your project. This file will store sensitive information like your database credentials and port number. Add the following line to your `.env` file:

```
PORT = 8000
```

To use environment variables in your Node.js application, you need to install the `dotenv` package. Run the following command:

```bash
npm install dotenv
```

### Creating the `index.js` File

Now, create an `index.js` file in the root directory of your project and add the following code:

```javascript
const express = require('express');
const bodyParser = require('body-parser');

require('dotenv').config();

const app = express();

// Middlewares
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());

app.use('/', (req, res) => {
    return res.json({ 'msg': "this is the home page."});
});

app.listen(process.env.PORT, async () => {
    console.log(`Server Started at port: ${process.env.PORT}`);
})
```

**Code explanation:**

* `const express = require('express');`: This line imports the Express.js library, which provides functions for creating web applications and APIs.
* `const bodyParser = require('body-parser');`: This line imports the `body-parser` middleware, which is used to parse incoming request bodies.
* `require('dotenv').config();`: This line loads environment variables from the `.env` file into the `process.env` object, making them accessible in your application.
* `const app = express();`: This line creates an instance of the Express application.
* `app.use(bodyParser.urlencoded({ extended: false }));`: This middleware configures `body-parser` to handle URL-encoded data submitted through forms. `extended: false` uses the built-in querystring library.
* `app.use(bodyParser.json());`: This middleware configures `body-parser` to parse incoming requests with JSON payloads.
* `app.use('/', (req, res) => { return res.json({ 'msg': "this is the home page."}); });`: This defines a simple route for the root path (`/`). When a GET request is made to this path, the server will respond with a JSON object containing the message "this is the home page.".
* `app.listen(process.env.PORT, async () => { console.log(\`Server Started at port: ${process.env.PORT}\`); })`: This line starts the Express server and makes it listen for incoming requests on the port specified in the `PORT` environment variable. The callback function logs a message to the console indicating that the server has started.

### Connecting with the PostgreSQL Database

Now, we will establish a connection between our Node.js application and the PostgreSQL database.

**Note:** It is assumed that PostgreSQL is already installed on your local computer. If not, you can download it from the official PostgreSQL website: [https://www.postgresql.org/download/windows/](https://www.postgresql.org/download/windows/)

We will use Sequelize, an Object-Relational Mapping (ORM) library for Node.js, to define and interact with our database. We will also use `sequelize-cli`, a command-line interface for Sequelize, which helps automate common tasks such as creating models, migrations, and seed files. Additionally, we need the `pg` package (Sequelize uses it internally to connect and communicate with PostgreSQL) and `pg-hstore`, a serializer/deserializer for PostgreSQL's `hstore` data type, which Sequelize uses when your models include fields of the `hstore` type.

Install these dependencies using the following commands:

```bash
npm install --save sequelize pg pg-hstore
npm install --save-dev sequelize-cli
```

After installing the necessary packages, run the Sequelize CLI initialization command:

```bash
npx sequelize-cli init
```

This command will create the following folders in your project directory:

* `config`: Contains the `config.js` file, which holds the database connection configuration.
* `models`: Will contain the model definitions for your database tables.
* `migrations`: Will contain the migration files, which are used to manage changes to your database schema.
* `seeders`: Contain seed files, which can be used to populate your database with initial data.

### Configuring Database Credentials

Add your PostgreSQL database configuration details to the `.env` file:

```
DB_USERNAME = "your_db_username"
DB_PASSWORD = "your_db_password"
DB_DATABASE = "your_database_name"
DB_HOST = "127.0.0.1"
DB_DIALECT = "postgres" // PostgreSQL database
DB_PORT = "5432"  // Default port used by PostgreSQL
```

Now, we will edit the `config/config.json` file to tell Sequelize how to connect to your database. First, rename the `config.json` file to `config.js` because we will be using environment variables in this configuration file. Then, replace the contents of `config.js` with the following code:

```javascript
require('dotenv').config();

module.exports = {
    development: {
        username : process.env.DB_USERNAME,
        password : process.env.DB_PASSWORD,
        database : process.env.DB_DATABASE,
        host : process.env.DB_HOST,
        dialect : process.env.DB_DIALECT,
        port : process.env.DB_PORT,
    },
    test: {
        username : process.env.DB_USERNAME,
        password : process.env.DB_PASSWORD,
        database : process.env.DB_DATABASE,
        host : process.env.DB_HOST,
        dialect : process.env.DB_DIALECT,
        port : process.env.DB_PORT,
    },
    production: {
        username : process.env.DB_USERNAME,
        password : process.env.DB_PASSWORD,
        database : process.env.DB_DATABASE,
        host : process.env.DB_HOST,
        dialect : process.env.DB_DIALECT,
        port : process.env.DB_PORT,
    },
};
```

**Code explanation:**

This file exports a configuration object that defines different database connection settings for different environments (`development`, `test`, and `production`). It reads the database credentials (username, password, database name, host, dialect, and port) from the environment variables defined in your `.env` file. This approach is more secure than hardcoding credentials directly in the configuration file.

### Updating the `models/index.js` File

The `models/index.js` file is responsible for connecting to the database and loading all the defined models. It initially uses the `config.json` file for database configuration. Since we have renamed it to `config.js`, we need to update the path in `models/index.js`. Open the `models/index.js` file and change the following line:

```javascript
const config = require(__dirname + '/../config/config.json')[env];
```

to:

```javascript
const config = require(__dirname + '/../config/config.js')[env];
```

With this change, your Node.js application is now successfully connected to your PostgreSQL database. In the next steps, we will create the user model and define the necessary database migrations.

---


Okay, here's the second part of your article, professionally written with grammar corrections and explanations:

## Creating the Database and User Model

With Sequelize set up, we can now proceed to create our database and define the structure for our user data.

### Creating the Database

Sequelize CLI provides a convenient command to create the database based on the configuration you've provided in your `.env` file. Run the following command in your terminal:

```bash
npx sequelize-cli db:create
```

This command will execute and create the database specified by the `DB_DATABASE` variable in your `.env` file within your PostgreSQL instance.

### Generating the User Migration

Next, we need to create a migration file that will define the `Users` table in our database. Use the Sequelize CLI to generate this migration file:

```bash
npx sequelize-cli migration:generate --name create-user-table
```

This command will create a new JavaScript file in your `migrations` folder. The filename will be timestamped, for example, `20250502045839-create-user-table.js`.

Open this newly created migration file and replace its contents with the following code:

```javascript
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
    async up(queryInterface, Sequelize) {
        await queryInterface.createTable('Users', {
            id: {
                allowNull: false,
                autoIncrement: true,
                primaryKey: true,
                type: Sequelize.INTEGER,
            },
            name: {
                type: Sequelize.STRING,
                allowNull: false,
            },
            email: {
                type: Sequelize.STRING,
                allowNull: false,
                unique: true,
            },
            email_verified_at: {
                type: Sequelize.DATE,
            },
            password: {
                type: Sequelize.STRING,
                allowNull: false,
            },
            createdAt: {
                allowNull: false,
                type: Sequelize.DATE,
            },
            updatedAt: {
                allowNull: false,
                type: Sequelize.DATE,
            },
        });
    },

    async down(queryInterface, Sequelize) {
        await queryInterface.dropTable('Users');
    }
};
```

**Code Explanation:**

* `'use strict';`: This directive enforces stricter parsing and error handling in your JavaScript code.
* `module.exports = { ... };`: This exports an object containing two asynchronous functions: `up` and `down`.
* `async up(queryInterface, Sequelize) { ... }`: This function is executed when you run the migrations. It defines the changes to be made to the database schema.
    * `await queryInterface.createTable('Users', { ... });`: This asynchronously creates a table named `Users`.
    * `id: { ... }`: Defines the `id` column as the primary key, which is an automatically incrementing integer and cannot be `null`.
    * `name: { ... }`: Defines the `name` column as a string that cannot be `null`.
    * `email: { ... }`: Defines the `email` column as a string that cannot be `null` and must be unique.
    * `email_verified_at: { ... }`: Defines the `email_verified_at` column as a date, which will store the timestamp when the email was verified (can be `null` initially).
    * `password: { ... }`: Defines the `password` column as a string that cannot be `null`.
    * `createdAt: { ... }`: Sequelize automatically adds this timestamp column to track when a record was created.
    * `updatedAt: { ... }`: Sequelize automatically adds this timestamp column to track when a record was last updated.
* `async down(queryInterface, Sequelize) { ... }`: This function is executed when you rollback the migrations. It defines how to undo the changes made by the `up` function.
    * `await queryInterface.dropTable('Users');`: This asynchronously drops the `Users` table.

### Creating the User Model

Now, let's define the Sequelize model that corresponds to our `Users` table. Create a new file named `user.js` inside the `models` folder and add the following code:

```javascript
'use strict';

const { Model } = require('sequelize');

module.exports = (sequelize, DataTypes) => {
    class User extends Model {
        // This method is used to define model relations
        // static associate(models){
        //
        // }
    }

    User.init({
        name: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        email: {
            type: DataTypes.STRING,
            allowNull: false,
            unique: true,
            validate: {
                isEmail: true,
            }
        },
        email_verified_at: {
            type: DataTypes.DATE,
        },
        password: {
            type: DataTypes.STRING,
            allowNull: false,
        }
    }, {
        sequelize,
        modelName: 'User',
    });

    return User;
};
```

**Code Explanation:**

* `'use strict';`: Enforces stricter parsing and error handling.
* `const { Model } = require('sequelize');`: Imports the `Model` class from the Sequelize library.
* `module.exports = (sequelize, DataTypes) => { ... };`: Exports a function that takes the Sequelize instance and the `DataTypes` object as arguments. This function defines and returns the `User` model.
* `class User extends Model { ... }`: Defines the `User` model class, which extends the Sequelize `Model` class.
    * `// static associate(models){ ... }`: This commented-out section is where you would define associations with other models if your application had them (e.g., a User might have many Posts).
* `User.init({ ... }, { ... });`: This method initializes the model's attributes and options.
    * The first argument is an object defining the model's attributes (columns):
        * `name`: A string that cannot be `null`.
        * `email`: A string that cannot be `null` and must be unique. It also includes a `validate` option to ensure the value is a valid email format.
        * `email_verified_at`: A date to store the email verification timestamp.
        * `password`: A string that cannot be `null`.
    * The second argument is an object defining the model's options:
        * `sequelize`: The Sequelize instance used to connect to the database.
        * `modelName`: The name of the model, which Sequelize will automatically pluralize to `Users` for the database table name (unless explicitly configured otherwise).
* `return User;`: Returns the defined `User` model.

### Running the Migrations

To apply the changes defined in your migration file to your PostgreSQL database, run the following Sequelize CLI command:

```bash
npx sequelize-cli db:migrate
```

This command will execute all pending migration files in your `migrations` folder, creating the `Users` table with the specified columns in your database.

### Setting Up Authentication Routes and Controller

Now, we will create a dedicated folder for our routes and define the route for user registration.

Create a `routes` folder in the root directory of your project and inside it, create a file named `auth.js`.

We will use the `express-validator` middleware to validate the incoming registration data. If you haven't already, install it using the following command:

```bash
npm install express-validator
```

Open the `routes/auth.js` file and add the following code:

```javascript
const { Router } = require("express");
const { body } = require('express-validator');
const { register } = require("../controllers/auth");
const router = Router();

const validateRegister = [
    body('name').isLength({ min: 4 }).notEmpty().withMessage('Oops! Name is required.').trim().escape(),
    body('email').isEmail().notEmpty().withMessage('Oops! Email is required.').trim().escape(),
    body('password').isLength({ min: 8 }).withMessage('Oops! Password must be at least 8 characters long.').trim().escape(),
];

router.post('/register', validateRegister, register);

module.exports = router;
```

**Code Explanation:**

* `const { Router } = require("express");`: Imports the `Router` class from Express, which is used to create modular route handlers.
* `const { body } = require('express-validator');`: Imports the `body` validator from the `express-validator` library, used to validate data in the request body.
* `const { register } = require("../controllers/auth");`: Imports the `register` function from the `auth` controller file (which we will create next).
* `const router = Router();`: Creates a new router instance.
* `const validateRegister = [ ... ];`: Defines an array of validation rules for the registration route.
    * `body('name').isLength({ min: 4 }).notEmpty().withMessage('Oops! Name is required.').trim().escape()`: Validates the `name` field in the request body. It checks if the length is at least 4 characters, is not empty, trims whitespace, and escapes HTML characters to prevent XSS attacks.
    * `body('email').isEmail().notEmpty().withMessage('Oops! Email is required.').trim().escape()`: Validates the `email` field. It checks if it's a valid email format, is not empty, trims whitespace, and escapes HTML characters.
    * `body('password').isLength({ min: 8 }).withMessage('Oops! Password must be at least 8 characters long.').trim().escape()`: Validates the `password` field. It checks if the length is at least 8 characters, trims whitespace, and escapes HTML characters.
* `router.post('/register', validateRegister, register);`: Defines a POST route at `/register`. When a POST request is made to this endpoint, the `validateRegister` middleware will be executed first to validate the request body. If the validation is successful, the `register` controller function will be called.
* `module.exports = router;`: Exports the router instance so it can be used by the main application.

### Installing Authentication Dependencies

We will use `bcryptjs` for securely hashing user passwords, `jsonwebtoken` for generating and verifying authentication tokens, and `passport` along with `passport-jwt` strategy for handling authentication. Install these dependencies using the following command:

```bash
npm install passport passport-jwt jsonwebtoken bcryptjs
```

### Creating the Authentication Controller

Now, create a `controllers` folder in the root directory of your project, and inside it, create a file named `auth.js`. In this file, we will define the logic for user registration.

Open the `controllers/auth.js` file and add the following code:

```javascript
const { validationResult } = require("express-validator");
const db = require('../models');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

require('dotenv').config();
const User = db.User;

exports.register = async (req, res) => {
    const errors = validationResult(req);

    // Return validation errors if any
    if (!errors.isEmpty()) {
        return res.status(400).json({ // Changed status code to 400 for bad request
            status: 'error',
            msg: 'Validation error',
            errors: errors.array()
        });
    }

    try {
        const { name, email, password } = req.body;

        // Check if the user with the given email already exists
        const existingUser = await User.findOne({ where: { email } });
        if (existingUser) {
            return res.status(409).json({ // Changed status code to 409 for conflict
                status: 'error',
                msg: 'User with this email already exists.',
            });
        }

        // Hash the password
        const hashedPassword = await bcrypt.hash(password, 12);

        // Create the new user in the database
        const user = await User.create({
            name,
            email,
            password: hashedPassword,
        });

        // Generate a JWT token
        const token = jwt.sign(
            { id: user.id },
            process.env.JWT_SECRET_KEY,
            {
                expiresIn: process.env.JWT_EXPIRATION_TIME,
            }
        );

        return res.status(201).json({ // Changed status code to 201 for created
            status: 'success',
            msg: 'User created successfully.',
            user: {
                id: user.id,
                name: user.name,
                email: user.email,
                token,
            },
        });
    } catch (error) {
        console.error(error);
        return res.status(500).json({
            status: 'error',
            msg: 'Internal server error.',
            errors: error.message, // Sending a more specific error message for debugging
        });
    }
};
```

**Code Explanation:**

* `const { validationResult } = require("express-validator");`: Imports the `validationResult` function, which allows you to check for validation errors from the `express-validator` middleware.
* `const db = require('../models');`: Imports the Sequelize models defined in the `../models` directory.
* `const jwt = require('jsonwebtoken');`: Imports the `jsonwebtoken` library for creating and verifying JWTs.
* `const bcrypt = require('bcryptjs');`: Imports the `bcryptjs` library for password hashing.
* `require('dotenv').config();`: Loads environment variables from the `.env` file.
* `const User = db.User;`: Assigns the `User` model to a constant for easier use.
* `exports.register = async (req, res) => { ... };`: Defines the asynchronous `register` controller function, which handles user registration.
    * `const errors = validationResult(req);`: Checks for any validation errors that might have occurred during the `validateRegister` middleware execution.
    * `if (!errors.isEmpty()) { ... }`: If there are validation errors, it returns a 400 Bad Request response with an error message and an array of the validation errors.
    * `try { ... }`: Encloses the code that might throw an error in a `try...catch` block for error handling.
        * `const { name, email, password } = req.body;`: Extracts the `name`, `email`, and `password` from the request body.
        * `const existingUser = await User.findOne({ where: { email } });`: Queries the database to check if a user with the provided email already exists.
        * `if (existingUser) { ... }`: If a user with the same email is found, it returns a 409 Conflict response indicating that the email is already taken.
        * `const hashedPassword = await bcrypt.hash(password, 12);`: Asynchronously hashes the user's password using `bcryptjs` with a salt factor of 12 (a measure of how much time it takes to generate the hash, increasing security).
        * `const user = await User.create({ name, email, password: hashedPassword });`: Creates a new user record in the database with the provided name, email, and the hashed password.
        * `const token = jwt.sign({ id: user.id }, process.env.JWT_SECRET_KEY, { expiresIn: process.env.JWT_EXPIRATION_TIME });`: Generates a JSON Web Token (JWT).
            * `{ id: user.id }`: The payload of the token, containing the user's ID.
            * `process.env.JWT_SECRET_KEY`: A secret key used to sign the token (should be a strong, randomly generated string stored in your `.env` file).
            * `{ expiresIn: process.env.JWT_EXPIRATION_TIME }`: Options for the token, in this case, setting an expiration time (e.g., '1h' for one hour, '30m' for 30 minutes) defined in your `.env` file.
        * `return res.status(201).json({ ... });`: If the user is created successfully, it returns a 201 Created response with a success message and the user's information (excluding the password) along with the generated token.
    * `catch (error) { ... }`: If any error occurs during the process, it logs the error to the console and returns a 500 Internal Server Error response with an error message.

If the user is created successfully, the API will return a JSON response similar to the one you provided:

```json
{
    "status": "success",
    "msg": "User created successfully.",
    "user": {
        "id": 3,
        "name": "testing user1",
        "email": "test1@gmail.com",
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MywiaWF0IjoxNzQ2MjcwMDY0LCJleHAiOjE3NDYyNzM2NjR9.11X_QNR27NFyczwWOuTFEJ9l8o9Us02h-D0P8YLQw74"
    }
}
```

Remember to include the `auth.js` route in your main `index.js` file to make it accessible. You can do this by adding the following lines to your `index.js`:

```javascript
const authRoutes = require('./routes/auth');
app.use('/api/auth', authRoutes);
```

This will mount all the routes defined in `auth.js` under the `/api/auth` prefix.

Alright, let's integrate the login functionality, dashboard route, and JWT authentication middleware into your article.

## Implementing Login and Protecting Routes with JWT

Now that we have user registration set up, we will implement the login functionality and protect specific routes using JSON Web Tokens (JWT).

### Implementing the Login Function in the Auth Controller

Open your `controllers/auth.js` file and add the following `login` function:

```javascript
exports.login = async (req, res) => {
    const errors = validationResult(req);

    // Return validation errors if any
    if (!errors.isEmpty()) {
        return res.status(400).json({
            status: 'error',
            msg: 'Validation error',
            errors: errors.array()
        });
    }

    try {
        const { email, password } = req.body;
        const user = await User.findOne({ where: { email } });

        if (!user || !(await bcrypt.compare(password, user.password))) {
            return res.status(401).json({
                status: 'error',
                msg: 'Invalid credentials',
                errors: [{ msg: "Invalid credentials" }]
            });
        }

        // Generate user token
        const token = jwt.sign(
            { id: user.id },
            process.env.JWT_SECRET_KEY,
            {
                expiresIn: process.env.JWT_EXPIRATION_TIME,
            }
        );

        return res.status(200).json({
            status: 'success',
            msg: 'Logged in successfully.',
            user: {
                name: user.name,
                email: user.email,
                token
            }
        });
    } catch (error) {
        console.error(error);
        return res.status(500).json({
            status: 'error',
            error: error.message,
            msg: 'Internal server error.'
        });
    }
};
```

**Code Explanation:**

* This `login` function handles user login requests.
* It first validates the incoming `email` and `password` using `express-validator`.
* It then attempts to find a user in the database with the provided email.
* If no user is found or if the provided password does not match the hashed password in the database (using `bcrypt.compare`), it returns a 401 Unauthorized response with an "Invalid credentials" message.
* If the credentials are valid, it generates a new JWT token for the user, similar to the registration process.
* Finally, it returns a 200 OK response with a success message and the user's information (excluding the password) along with the generated token.

### Implementing the Dashboard Function in the Auth Controller

Add the following `dashboard` function to your `controllers/auth.js` file:

```javascript
exports.dashboard = async (req, res) => {
    return res.status(200).json({
        msg: "This is the Dashboard Page."
    });
};
```

**Code Explanation:**

* This `dashboard` function is a protected route that will only be accessible to authenticated users.
* It simply returns a 200 OK response with a message indicating it's the dashboard page.

### Creating the Login Route

Open your `routes/auth.js` file and add the following validation middleware and route for the login function:

```javascript
const { login } = require("../controllers/auth");

const validateLogin = [
    body('email').isEmail().notEmpty().withMessage('Oops! Email is required.').trim().escape(),
    body('password').notEmpty().withMessage('Oops! Password is required.').trim().escape(),
];

router.post('/login', validateLogin, login);
```

**Code Explanation:**

* This code defines a new validation middleware `validateLogin` to ensure that the `email` is a valid email format and both `email` and `password` are not empty.
* It then defines a POST route at `/login`. When a POST request is made to this endpoint, the `validateLogin` middleware will be executed first, followed by the `login` controller function if the validation is successful.

### Configuring Passport for JWT Authentication

Create a new folder named `config` in the root directory of your project and create a file named `passport.js` inside it. Add the following code to this file:

```javascript
const { ExtractJwt, Strategy: JwtStrategy } = require('passport-jwt');
const passport = require('passport');
const db = require('../models');
const User = db.User;

let options = {
    jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
    secretOrKey: process.env.JWT_SECRET_KEY,
};

require('dotenv').config();

passport.use(new JwtStrategy(options, async (jwt_payload, done) => {
    try {
        const user = await User.findByPk(jwt_payload.id);
        if (!user) {
            return done(null, false);
        }

        // Success, return user
        return done(null, user);

    } catch (error) {
        return done(error, false);
    }
}));

module.exports = passport;
```

**Code Explanation:**

* This file configures the `passport-jwt` strategy for Passport.
* `const { ExtractJwt, Strategy: JwtStrategy } = require('passport-jwt');`: Imports the necessary modules from the `passport-jwt` library. `ExtractJwt.fromAuthHeaderAsBearerToken()` specifies how the JWT should be extracted from the incoming request (in this case, from the `Authorization` header as a Bearer token). `JwtStrategy` is the Passport strategy for authenticating users using JWTs.
* `const passport = require('passport');`: Imports the Passport library.
* `const db = require('../models');`: Imports the Sequelize models.
* `const User = db.User;`: Assigns the `User` model to a constant.
* `let options = { ... };`: Defines the options for the JWT strategy:
    * `jwtFromRequest`: Specifies the function to extract the JWT from the request. Here, it's configured to extract the token from the `Authorization` header with the `Bearer ` scheme.
    * `secretOrKey`: This is the secret key used to sign the JWT. It should match the `JWT_SECRET_KEY` used when generating the token.
* `passport.use(new JwtStrategy(options, async (jwt_payload, done) => { ... }));`: This registers a new JWT strategy with Passport. It takes two arguments:
    * `options`: The configuration options defined earlier.
    * An asynchronous callback function that will be called when a JWT is successfully extracted and verified.
        * `jwt_payload`: This object contains the decoded payload of the JWT (in our case, it will contain the `id` of the user).
        * `done`: This is a callback function that Passport provides to signal the result of the authentication. It takes three possible arguments:
            * `err`: An error object if an error occurred during the process.
            * `user`: The authenticated user object if authentication is successful.
            * `info`: An optional object with additional information about the authentication result (e.g., if the token is invalid).
        * Inside the callback:
            * It attempts to find a user in the database using the `id` from the `jwt_payload`.
            * If no user is found, it calls `done(null, false)`, indicating that authentication failed without an error.
            * If a user is found, it calls `done(null, user)`, indicating successful authentication and passing the user object.
            * If an error occurs during the database query, it calls `done(error, false)`.
* `module.exports = passport;`: Exports the configured Passport instance.

### Initializing Passport in `index.js`

Open your main `index.js` file and add the following lines to initialize Passport:

```javascript
const passport = require('passport');

require('./config/passport');

app.use(passport.initialize());
```

**Code Explanation:**

* `const passport = require('passport');`: Imports the Passport instance configured in `./config/passport.js`.
* `require('./config/passport');`: Imports and executes the `passport.js` file, which registers the JWT strategy with the Passport instance.
* `app.use(passport.initialize());`: Initializes the Passport middleware. This is required to use Passport in your Express application.

Ensure that the order of your middleware in `index.js` is correct, especially placing `passport.initialize()` before any routes that use Passport for authentication. Your `index.js` file should now look like this:

```javascript
const express = require('express');
const bodyParser = require('body-parser');
const authRoutes = require('./routes/auth');
const passport = require('passport');

require('dotenv').config();
require('./config/passport');

const app = express();

// Middlewares
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());

app.use(passport.initialize());

app.use('/api/auth', authRoutes);
app.use('/', (req, res) => {
    return res.json({ 'msg': "this is the home page."});
});

app.listen(process.env.PORT, async () => {
    console.log(`Server Started at port: ${process.env.PORT}`);
})
```

**Code Explanation:**

The order of middleware matters in Express. Here's why this order is important:

1.  `bodyParser.urlencoded({ extended: false })` and `bodyParser.json()`: These middleware are used to parse the request body. They need to be executed before your route handlers so that `req.body` contains the parsed data.
2.  `passport.initialize()`: This middleware initializes Passport. It sets up Passport for use in your application, including setting up the necessary internal state. It needs to be called before any middleware that uses Passport's authentication strategies.
3.  `app.use('/api/auth', authRoutes)`: This mounts the authentication routes defined in `authRoutes` under the `/api/auth` path. These routes include `/register` and `/login`, which don't require authentication, so they can come after Passport initialization.
4.  `app.use('/', (req, res) => { ... })`: This is a simple home page route. It doesn't depend on authentication.

### Creating the JWT Authentication Middleware

Create a new folder named `middlewares` in the root directory of your project and create a file named `authenticateJWT.js` inside it. Add the following code to this file:

```javascript
const passport = require('passport');

const authenticateJWT = (req, res, next) => {
    passport.authenticate('jwt', { session: false }, (err, user, info) => {
        if (err) {
            return res.status(500).json({ message: 'Internal server error' });
        }

        if (!user) {
            if (info?.name === 'TokenExpiredError') {
                return res.status(401).json({
                    message: 'Token expired, Please log in again.'
                });
            }

            if (info?.message === 'No auth token') {
                return res.status(401).json({ message: 'No token provided' });
            }

            return res.status(401).json({ message: 'Invalid token' });
        }
        req.user = user;
        next();
    })(req, res, next);
};

module.exports = authenticateJWT;
```

**Code Explanation:**

* `const passport = require('passport');`: Imports the configured Passport instance.
* `const authenticateJWT = (req, res, next) => { ... };`: Defines a middleware function named `authenticateJWT`. This function will be used to protect routes that require authentication.
* `passport.authenticate('jwt', { session: false }, (err, user, info) => { ... })(req, res, next);`: This is the core of the middleware.
    * `'jwt'`: Specifies the Passport strategy to use (the JWT strategy we configured in `passport.js`).
    * `{ session: false }`: Tells Passport not to create a session for the user. JWT authentication is typically stateless, so we don't need sessions.
    * `(err, user, info) => { ... }`: This is the callback function that Passport calls after attempting to authenticate the user using the JWT.
        * `err`: An error object if an error occurred during authentication.
        * `user`: The authenticated user object if the token is valid.
        * `info`: An object containing additional information about the authentication process (e.g., error messages from the JWT verification).
        * Inside the callback:
            * `if (err) { ... }`: If there's an error, it returns a 500 Internal Server Error response.
            * `if (!user) { ... }`: If the `user` is `null` (meaning authentication failed):
                * It checks the `info` object for specific error messages:
                    * If `info?.name === 'TokenExpiredError'`, it returns a 401 Unauthorized response with a "Token expired" message.
                    * If `info?.message === 'No auth token'`, it returns a 401 Unauthorized response with a "No token provided" message.
                    * Otherwise, it returns a generic "Invalid token" message.
            * `req.user = user;`: If the user is authenticated successfully, it attaches the `user` object to the `req` object, making it accessible in subsequent route handlers.
            * `next();`: Calls the next middleware in the chain, allowing the request to proceed to the route handler.
    * `(req, res, next)`: Immediately invokes the Passport authentication middleware with the current request, response, and next function.

### Protecting the Dashboard Route

Now, open your `routes/auth.js` file and add the `authenticateJWT` middleware to the dashboard route:

```javascript
const authenticateJWT = require("../middlewares/authenticateJWT");
const { dashboard } = require("../controllers/auth");

// ... other routes ...

router.get('/dashboard', authenticateJWT, dashboard);
```

**Code Explanation:**

By adding `authenticateJWT` as middleware before the `dashboard` route handler, we ensure that only requests with a valid JWT will be able to access the `/dashboard` endpoint. If a request to `/dashboard` does not have a valid JWT in the `Authorization` header, the `authenticateJWT` middleware will return a 401 Unauthorized response.

With these steps, you have now implemented user login and protected a route using JWT authentication. Users can register, log in to receive a token, and then use that token to access protected routes like the `/dashboard`.

*****************************************************************************************************

Great! You've successfully built the backend. Now, let's move on to creating the React.js frontend. Here's the breakdown of the steps you've taken and explanations for the code:

## Building the Frontend with React.js

Now that our backend authentication system is complete, we will build the frontend using React.js to interact with our API.

### Creating a New React Application

Open a new terminal window (or navigate out of your backend project directory) and run the following command to create a new React application:

```bash
npx create-react-app frontend
```

This command uses Create React App to set up a basic React project structure in a folder named `frontend`.

### Navigating to the Frontend Directory

Once the React app is created, navigate into the newly created `frontend` directory:

```bash
cd frontend
```

### Installing Required Packages

Next, we need to install some essential libraries for state management, routing, and making API calls:

```bash
npm install redux react-redux @reduxjs/toolkit react-router-dom
```

**Package Explanation:**

* `redux`: A predictable state container for JavaScript apps.
* `react-redux`: Provides bindings between React and Redux.
* `@reduxjs/toolkit`: An opinionated battery-included toolset for efficient Redux development.
* `react-router-dom`: Provides the necessary components for implementing routing in your React application.

### Setting Up Redux

We will now set up Redux for managing the user authentication state in our frontend. Create the following folder structure within your `src` directory:

```
src
└── redux
    ├── slices
    │   └── userSlice.js
    └── store.js
```

### Creating the `userSlice`

Inside the `slices` folder, create a file named `userSlice.js` and add the following code:

```javascript
import { createSlice } from '@reduxjs/toolkit';

const initialState = {
    data: {
        firstName: '',
        lastName: '',
        email: '',
        profile_image: '',
        fullname: '',
    },
    isAuthenticated: false,
};

const userSlice = createSlice({
    name: 'user',
    initialState,
    reducers: {
        login: (state, action) => {
            const { data } = action.payload;
            state.data = data;
            state.isAuthenticated = true;
        },
        logout: ( state ) => {
            state.data = {
                firstName: '',
                lastName: '',
                email: '',
                profile_image: '',
                fullname: '',
            };
            state.isAuthenticated = false;
        }
    }
});

export const { login, logout } = userSlice.actions;
export default userSlice.reducer;
```

**Code Explanation:**

* `import { createSlice } from '@reduxjs/toolkit';`: Imports the `createSlice` function from Redux Toolkit, which simplifies the process of creating Redux slices (reducers and actions).
* `const initialState = { ... };`: Defines the initial state for the `user` slice. It includes an object `data` to store user information and a boolean `isAuthenticated` to track the user's login status.
* `const userSlice = createSlice({ ... });`: Creates a Redux slice named `user`.
    * `name: 'user'`: The name of the slice. This will be used as the key in the Redux store.
    * `initialState`: The initial state defined above.
    * `reducers: { ... }`: An object containing reducer functions. Reducers define how the state should change in response to actions.
        * `login: (state, action) => { ... }`: This reducer handles the `login` action. It takes the current state and an `action` object as arguments. The `action.payload` is expected to contain a `data` object with user information. It updates the `state.data` with the payload and sets `state.isAuthenticated` to `true`.
        * `logout: (state) => { ... }`: This reducer handles the `logout` action. It resets the `state.data` to its initial empty values and sets `state.isAuthenticated` to `false`.
* `export const { login, logout } = userSlice.actions;`: Exports the action creators generated by `createSlice`. These action creators can be dispatched to trigger the corresponding reducers.
* `export default userSlice.reducer;`: Exports the reducer function generated by `createSlice`. This reducer will be combined with other reducers in the Redux store.

### Creating the Redux Store

Inside the `redux` folder, create a file named `store.js` and add the following code:

```javascript
import { configureStore } from '@reduxjs/toolkit';
import userSlice from './slices/userSlice';

export const store = configureStore({
    reducer: {
        user: userSlice,
    }
});
```

**Code Explanation:**

* `import { configureStore } from '@reduxjs/toolkit';`: Imports the `configureStore` function from Redux Toolkit, which simplifies the creation of a Redux store.
* `import userSlice from './slices/userSlice';`: Imports the reducer from the `userSlice`.
* `export const store = configureStore({ ... });`: Configures and exports the Redux store.
    * `reducer: { user: userSlice }`: Defines the root reducer of the store. Here, we are assigning the `userSlice` reducer to the `user` key in the state. This means that the user-related state will be accessible in the Redux store under `state.user`.

### Editing the `index.js` File

Open the `src/index.js` file in your frontend and modify it as follows:

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import { BrowserRouter as Router } from 'react-router-dom';
import { store } from './redux/store';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
    <React.StrictMode>
        <Router>
            <Provider store={store}>
                <App />
            </Provider>
        </Router>
    </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
```

**Code Explanation:**

* `import { Provider } from 'react-redux';`: Imports the `Provider` component from `react-redux`. This component makes the Redux store available to all nested components.
* `import { BrowserRouter as Router } from 'react-router-dom';`: Imports the `BrowserRouter` component from `react-router-dom`. This component enables routing functionality in your React application.
* `import { store } from './redux/store';`: Imports the Redux store we configured in `redux/store.js`.
* The `<Provider store={store}>` component wraps the `<App />` component. This makes the Redux store accessible to all components within the `<App />` tree through the `useSelector` and `useDispatch` hooks.
* The `<Router>` component wraps the `<Provider>`, enabling routing within the application.

### Editing the `App.js` File

Open the `src/App.js` file and modify it as follows:

```javascript
import Router from './routes';

function App() {
    return <Router />;
}

export default App;
```

**Code Explanation:**

* `import Router from './routes';`: Imports the `Router` component that we will create in the `routes` folder.
* The `App` component now simply renders the `Router` component, which will handle the application's routing logic.

### Creating the Routes

Create a new folder named `routes` in the `src` directory and inside it, create a file named `index.js` with the following code:

```javascript
import { Routes, Route } from 'react-router-dom';

import LoginPage from '../pages/auth/LoginPage';
import RegisterPage from '../pages/auth/RegisterPage';
import Home from '../pages/Home';
import NotFound from '../pages/NotFound'; // You might want to create a NotFound page

function Router() {
    return (
        <Routes>
            {/* Public Routes */}
            <Route path='/' element={<Home />} />
            <Route path='/login' element={<LoginPage />} />
            <Route path='/register' element={<RegisterPage />} />

            {/* Page Not Found */}
            <Route path='*' element={<NotFound />} />
        </Routes>
    );
}

export default Router;
```

**Code Explanation:**

* `import { Routes, Route } from 'react-router-dom';`: Imports the `Routes` and `Route` components from `react-router-dom`, which are used to define the application's routes.
* `import LoginPage from '../pages/auth/LoginPage';`: Imports the `LoginPage` component (which we will create next).
* `import RegisterPage from '../pages/auth/RegisterPage';`: Imports the `RegisterPage` component (which we will create later).
* `import Home from '../pages/Home';`: Imports the `Home` component (which we will create later).
* `import NotFound from '../pages/NotFound';`: Imports a `NotFound` component to handle undefined routes. You'll need to create this in your `pages` directory.
* The `Router` component uses the `<Routes>` component to define a set of routes. Each `<Route>` component specifies a path and the component to render when that path is matched.
    * The `/` path renders the `Home` component.
    * The `/login` path renders the `LoginPage` component.
    * The `/register` path renders the `RegisterPage` component.
    * The `*` path acts as a catch-all for any undefined routes and renders the `NotFound` component.

### Creating the Login Page

Create a new folder named `pages` inside the `src` directory, then create another folder named `auth` inside `pages`. Inside `src/pages/auth`, create a file named `LoginPage.js` with the following code:

```javascript
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { login as loginReducer } from '../../redux/slices/userSlice';
import { login as loginApi } from '../../api/auth'; // Assuming you create an api/auth.js for API calls
import { storeToken } from '../../auth/token'; // Assuming you create an auth/token.js to handle token storage

export default function LoginPage() {
    const dispatch = useDispatch();
    const navigate = useNavigate();

    const [credentials, setCredentials] = useState({ email: "", password: "" });
    const [message, setMessage] = useState("");
    const [errors, setErrors] = useState([]);

    const handleChange = (e) => {
        setCredentials({ ...credentials, [e.target.name]: e.target.value });
    }

    const handleSubmit = async (e) => {
        e.preventDefault();
        setErrors([]);
        setMessage("");

        const response = await loginApi(credentials);

        if (response?.status === "success") {
            const user = response.user;
            setMessage(response.msg);
            storeToken(user.token);
            dispatch(loginReducer({ data: { name: user.name, email: user.email }, })); // Dispatch user data
            navigate('/');
        } else {
            console.error("Login failed:", response?.msg || response?.errors);
            setErrors(response?.errors || [{ msg: "Login failed. Please check your credentials." }]);
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h2>Login</h2>
            {errors.length > 0 && (
                <div style={{ color: 'red' }}>
                    {errors.map((err, idx) => (
                        <p key={idx}>{err?.msg || JSON.stringify(err)}</p>
                    ))}
                </div>
            )}
            {message && <p style={{ color: 'green' }}>{message}</p>}

            <input
                type='email'
                name='email'
                placeholder='Email'
                onChange={handleChange}
                value={credentials.email}
                required
            />
            <input
                type='password'
                name='password'
                placeholder='Password'
                onChange={handleChange}
                value={credentials.password}
                required
            />
            <button type='submit'>Login</button>
        </form>
    );
}
```

**Code Explanation:**

* `import React, { useState } from 'react';`: Imports the `useState` hook for managing local component state.
* `import { useDispatch } from 'react-redux';`: Imports the `useDispatch` hook to dispatch actions to the Redux store.
* `import { useNavigate } from 'react-router-dom';`: Imports the `useNavigate` hook for programmatic navigation.
* `import { login as loginReducer } from '../../redux/slices/userSlice';`: Imports the `login` action creator from the `userSlice`.
* `import { login as loginApi } from '../../api/auth';`: Imports a function named `login` from a hypothetical `../../api/auth.js` file. **You will need to create this file to handle the actual API call to your backend's `/api/auth/login` endpoint.**
* `import { storeToken } from '../../auth/token';`: Imports a function named `storeToken` from a hypothetical `../../auth/token.js` file. **You will need to create this file to handle storing the JWT token (e.g., in local storage or cookies).**
* `const [credentials, setCredentials] = useState({ email: "", password: "" });`: Initializes a state variable `credentials` to store the email and password entered by the user.
* `const [message, setMessage] = useState("");`: Initializes a state variable `message` to display success messages.
* `const [errors, setErrors] = useState([]);`: Initializes a state variable `errors` to store any error messages from the API.
* `const handleChange = (e) => { ... };`: An event handler that updates the `credentials` state when the input fields change.
* `const handleSubmit = async (e) => { ... };`: An asynchronous function that handles the form submission.
    * `e.preventDefault();`: Prevents the default form submission behavior.
    * It resets the `errors` and `message` state.
    * It calls the `loginApi` function (which you need to implement) with the `credentials`.
    * If the API call is successful (`response?.status === "success"`):
        * It extracts the `user` data from the response.
        * It sets the `message`.
        * It calls `storeToken` to save the JWT token.
        * It dispatches the `loginReducer` action to update the Redux store with the user's information.
        * It navigates the user to the home page (`/`).
    * If the API call fails, it logs the error and sets the `errors` state with the error messages from the API.
* The `return` statement renders a simple login form with input fields for email and password, a submit button, and displays any error or success messages.

**Next Steps:**

You will need to create the following files in your `frontend` directory:

1.  **`src/api/auth.js`**: This file will contain the function to make the API call to your backend's `/api/auth/login` endpoint using `fetch` or a library like Axios.
2.  **`src/auth/token.js`**: This file will contain functions to store and retrieve the JWT token (e.g., using `localStorage`).
3.  **`src/pages/auth/RegisterPage.js`**: Implement the registration page with similar logic to the login page, making a POST request to your backend's `/api/auth/register` endpoint.
4.  **`src/pages/Home.js`**: Create a simple home page.
5.  **`src/pages/NotFound.js`**: Create a component to display when a user navigates to an undefined route.

This sets up the basic structure and login functionality for your React frontend. Remember to implement the API call and token storage logic in the respective files. Let me know when you're ready to proceed with the registration page or other parts of the frontend!


Excellent! You're now connecting your React frontend to your Node.js backend. Let's break down the code and configurations you've added.

## Connecting the Frontend to the Backend API

To enable communication between your React frontend running on `http://localhost:3000` and your Node.js backend running on `http://127.0.0.1:8000`, you need to set up API call functions in your frontend and configure CORS in your backend.

### Creating the API Service (`src/api/auth.js`)

Create a new folder named `api` in your `src` directory, and inside it, create a file named `auth.js`. This file will contain functions to make API calls related to authentication.

#### Implementing the `login` Function

Add the following code to `src/api/auth.js`:

```javascript
const API_URL = 'http://127.0.0.1:8000';

export const login = async (credentials) => {
    const res = await fetch(`${API_URL}/api/auth/login`, {
        method: 'POST',
        credentials: 'include',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(credentials),
    });
    return res.json();
};
```

**Code Explanation:**

* `const API_URL = 'http://127.0.0.1:8000';`: Defines the base URL of your backend API.
* `export const login = async (credentials) => { ... };`: Exports an asynchronous function named `login` that takes user `credentials` (an object containing `email` and `password`) as input.
* `await fetch(`${API_URL}/api/auth/login`, { ... });`: Uses the `fetch` API to make a POST request to the `/api/auth/login` endpoint of your backend. **Note the corrected endpoint `/api/auth/login` based on your backend route definition.**
    * `method: 'POST'`: Specifies that this is a POST request, used for sending data to the server for login.
    * `credentials: 'include'`: This is important for handling cookies or HTTP authentication if your backend sets them.
    * `headers: { 'Content-Type': 'application/json' }`: Sets the `Content-Type` header to indicate that the request body will be in JSON format.
    * `body: JSON.stringify(credentials)`: Converts the `credentials` object into a JSON string to be sent in the request body.
* `return res.json();`: Parses the JSON response from the server and returns it.

### Creating the Token Storage (`src/auth/token.js`)

Create a new folder named `auth` in your `src` directory, and inside it, create a file named `token.js`. This file will handle storing and potentially retrieving the authentication token.

#### Implementing the `storeToken` Function

Add the following code to `src/auth/token.js`:

```javascript
export const storeToken = (token) => {
    const now = new Date();
    const item = {
        token: token,
        expiry: now.getTime() + 60 * 60 * 1000 // 1 hour in milliseconds
    };
    localStorage.setItem('authToken', JSON.stringify(item));
};
```

**Code Explanation:**

* `export const storeToken = (token) => { ... };`: Exports a function named `storeToken` that takes the JWT `token` as input.
* `const now = new Date();`: Creates a new `Date` object to get the current time.
* `const item = { token: token, expiry: now.getTime() + 60 * 60 * 1000 };`: Creates an object to store the `token` and its `expiry` time (set to 1 hour from the current time). Storing the expiry can be useful for automatically logging out users after a certain period on the frontend.
* `localStorage.setItem('authToken', JSON.stringify(item));`: Stores the `item` object (containing the token and expiry) in the browser's `localStorage` under the key `authToken`. `localStorage` provides persistent storage in the user's browser.

### Implementing the Registration Page (`src/pages/auth/RegisterPage.js`)

Create a file named `RegisterPage.js` inside the `src/pages/auth` directory and add the following code:

```javascript
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useDispatch } from 'react-redux';
import { register as registerApi } from '../../api/auth'; // Import the register API function
import { storeToken } from '../../auth/token';
import { login as loginReducer } from '../../redux/slices/userSlice';

export default function RegisterPage() {
    const dispatch = useDispatch();
    const navigate = useNavigate();
    const [formData, setFormData] = useState({
        name: '',
        email: '',
        password: '',
    });
    const [errors, setErrors] = useState([]);
    const [message, setMessage] = useState("");

    const handleChange = (e) => {
        setFormData({ ...formData, [e.target.name]: e.target.value });
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setErrors([]);
        setMessage("");

        const response = await registerApi(formData);

        if (response?.status === "success") {
            const user = response.user;
            setMessage(response.msg);
            storeToken(user.token);
            dispatch(loginReducer({ data: { name: user.name, email: user.email } }));
            navigate('/');
        } else {
            console.error("Registration failed:", response?.msg || response?.errors);
            setErrors(response?.errors || [{ msg: "Registration failed. Please try again." }]);
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h2>Register</h2>
            {errors.length > 0 && (
                <div style={{ color: 'red' }}>
                    {errors.map((err, idx) => (
                        <p key={idx}>{err?.msg || JSON.stringify(err)}</p>
                    ))}
                </div>
            )}
            {message && <p style={{ color: 'green' }}>{message}</p>}

            <input
                name='name'
                placeholder='Name'
                type='text'
                onChange={handleChange}
                value={formData.name}
                required
            />
            <input
                name='email'
                placeholder='Email'
                type='email'
                onChange={handleChange}
                value={formData.email}
                required
            />
            <input
                name='password'
                placeholder='Password'
                type='password'
                onChange={handleChange}
                value={formData.password}
                required
            />
            <button type='submit'>Register</button>
        </form>
    );
}
```

**Code Explanation:**

The `RegisterPage` component is very similar to the `LoginPage`. It handles user registration by:

* Importing necessary React hooks, Redux utilities, routing, and the API and token storage functions.
* Maintaining local state for the registration form data (`formData`), errors, and success messages.
* Using `handleChange` to update the form data as the user types.
* Using `handleSubmit` to:
    * Prevent default form submission.
    * Clear previous errors and messages.
    * Call the `registerApi` function (which you'll define next) with the form data.
    * If registration is successful:
        * Extract user data and the token from the response.
        * Store the token using `storeToken`.
        * Dispatch the `loginReducer` to update the Redux state.
        * Navigate the user to the home page.
    * If registration fails, it sets the `errors` state with the error messages from the API.
* Rendering a registration form with input fields for name, email, and password, along with error and success message displays.

### Implementing the `register` Function in `src/api/auth.js`

Add the following code to `src/api/auth.js`:

```javascript
// Register new user
export const register = async (userData) => {
    const res = await fetch(`${API_URL}/api/auth/register`, {
        method: 'POST',
        credentials: 'include',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(userData),
    });
    return res.json();
};
```

**Code Explanation:**

* This function is similar to the `login` function but makes a POST request to the `/api/auth/register` endpoint of your backend to register a new user. It sends the `userData` (an object containing `name`, `email`, and `password`) in the request body as JSON.

### Configuring CORS and Cookie Parser in the Backend (`index.js`)

To allow your React application running on `http://localhost:3000` to make requests to your Node.js backend running on `http://127.0.0.1:8000`, you need to configure Cross-Origin Resource Sharing (CORS) in your backend. You also need `cookie-parser` if your backend uses cookies for session management (though in this JWT-based authentication, it might not be strictly necessary for the token itself, but good practice to include).

Add the following to your backend's `index.js` file:

```javascript
const express = require('express');
const bodyParser = require('body-parser');
const authRoutes = require('./routes/auth');
const passport = require('passport');
const cookieParser = require('cookie-parser'); // Import cookie-parser
const cors = require("cors"); // Import cors

require('dotenv').config();
require('./config/passport');

const app = express();

// Middlewares
app.use(cors({
    origin: "http://localhost:3000", // Allow requests from your frontend
    credentials: true, // Allow sending/receiving cookies and authorization headers
}));
app.use(cookieParser()); // Use cookie-parser middleware
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());

app.use(passport.initialize());

app.use('/api/auth', authRoutes);
app.use('/', (req, res) => {
    return res.json({ 'msg': "this is the home page."});
});

app.listen(process.env.PORT, async () => {
    console.log(`Server Started at port: ${process.env.PORT}`);
})
```

**Code Explanation:**

* `const cookieParser = require('cookie-parser');`: Imports the `cookie-parser` middleware, which parses cookies attached to the client request.
* `const cors = require("cors");`: Imports the `cors` middleware, which enables Cross-Origin Resource Sharing.
* `app.use(cors({ ... }));`: Configures the CORS middleware:
    * `origin: "http://localhost:3000"`: Specifies that requests originating from `http://localhost:3000` (your React frontend's default development server address) should be allowed. In a production environment, you would replace this with your actual frontend domain.
    * `credentials: true`: This is crucial if you need to allow the exchange of credentials such as cookies or authorization headers between the frontend and backend.
* `app.use(cookieParser());`: Mounts the `cookie-parser` middleware, making cookies available in `req.cookies`.

### Configuring Proxy in Frontend (`frontend/package.json`)

To simplify API calls during development, you can configure a proxy in your React application's `package.json` file. This tells the Create React App development server to forward any requests to your backend's API URL if they are not local assets.

Add the following line to your `frontend/package.json` file, after the `"private": true` line:

```json
  "private": true,
  "proxy": "http://127.0.0.1:8000",
  "dependencies": {
    // ... other dependencies
  },
  // ... other configurations
```

**Code Explanation:**

* `"proxy": "http://127.0.0.1:8000"`: This tells the development server that any API requests (requests that don't match a static asset in your `public` folder) should be forwarded to `http://127.0.0.1:8000`. This allows you to make API calls in your frontend using relative paths like `/api/auth/login` instead of the full URL `http://127.0.0.1:8000/api/auth/login`. **Note the corrected path in your `login` and `register` API functions to reflect this proxy setup.**

With these configurations, your React frontend should now be able to communicate with your Node.js backend for user registration and login. Make sure your backend server is running when you test the frontend.

Let me know if you encounter any issues or if you'd like to proceed with implementing the home page or any other features!